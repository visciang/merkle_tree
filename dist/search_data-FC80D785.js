searchData={"items":[{"type":"module","title":"MerkleTree","doc":"# MerkleTree\n\n[![CI](https://github.com/visciang/merkle_tree/actions/workflows/ci.yml/badge.svg)](https://github.com/visciang/merkle_tree/actions/workflows/ci.yml)\n[![Docs](https://img.shields.io/badge/docs-latest-green.svg)](https://visciang.github.io/merkle_tree/readme.html) [![Coverage Status](https://coveralls.io/repos/github/visciang/merkle_tree/badge.svg?branch=main)](https://coveralls.io/github/visciang/merkle_tree?branch=main)\n\n(Sparse) Merkle Tree.\n\n`MerkleTree` implements `Enumerable` and `Collectable` protocols.","ref":"MerkleTree.html"},{"type":"module","title":"Quick start - MerkleTree","doc":"```elixir\nmt1 = MerkleTree.new(a: 0, b: 2, c: 3)\n\nmt2 =\n    mt1\n    |> MerkleTree.put(:a, 1)\n    |> MerkleTree.put(:d, 4)\n    |> MerkleTree.delete(:c)\n\n3 = MerkleTree.size(mt1) = MerkleTree.size(mt2)\nfalse = MerkleTree.merkle_equal?(mt1, mt2)\n[:d, :a, :c] = MerkleTree.merkle_diff(mt1, mt2)\n%{c: 3, a: 0, b: 2} = Map.new(mt1)\n```","ref":"MerkleTree.html#module-quick-start"},{"type":"function","title":"MerkleTree.compute_hashes/1","doc":"Compute the tree hashes.\n\nRefer to `:auto_comp_hash` `t:opts/0`.","ref":"MerkleTree.html#compute_hashes/1"},{"type":"function","title":"MerkleTree.delete/2","doc":"Deletes a tree key.","ref":"MerkleTree.html#delete/2"},{"type":"function","title":"MerkleTree.equal?/2","doc":"Checks if two trees are equal.\n\nThe equality is first checked leveraging the merkle tree hashes and in case of\nuncertaintainty with a default comparison algorithm.\n\nRaises if the hashes are not calculated (Refer to `:auto_comp_hash` `t:opts/0`).\n\nSee also `merkle_equal?/2`.","ref":"MerkleTree.html#equal?/2"},{"type":"function","title":"MerkleTree.fetch/2","doc":"Fetches a key value from the tree.","ref":"MerkleTree.html#fetch/2"},{"type":"function","title":"MerkleTree.first/1","doc":"Returns the first `{key, value}` (according to the merkle tree order).","ref":"MerkleTree.html#first/1"},{"type":"function","title":"MerkleTree.has_key?/2","doc":"Returns whether the given key exists in the tree.","ref":"MerkleTree.html#has_key?/2"},{"type":"function","title":"MerkleTree.iterator/1","doc":"Returns an iterator over the tree items, the iteration follows the merkle key tree order.\n\nThe iteration algorithm doesn't need to build the complete list of all elements at one time.","ref":"MerkleTree.html#iterator/1"},{"type":"function","title":"MerkleTree.keys/1","doc":"Returns all keys in the tree.","ref":"MerkleTree.html#keys/1"},{"type":"function","title":"MerkleTree.last/1","doc":"Returns the last `{key, value}` (according to the merkle tree order).","ref":"MerkleTree.html#last/1"},{"type":"function","title":"MerkleTree.merkle_diff/2","doc":"Returns the keys that differ (changed / removed / added) between two trees.\n\nThe diff is computed leveraging the merkle tree hashes and hence\nin case of hash collisions a wrong result could be returned.\n\nMore preciselly the diff reported is correct but could be incomplete.\n\nRaises if the hashes are not calculated (Refer to `:auto_comp_hash` `t:opts/0`).","ref":"MerkleTree.html#merkle_diff/2"},{"type":"function","title":"MerkleTree.merkle_equal?/2","doc":"Checks if two trees are (merkle) equal.\n\nThe equality is checked leveraging the merkle tree hashes and hence\nin case of hash collisions a wrong result could be returned.\n\nMore precisely if it reports that the trees are different than this is 100% true,\notherwise it means the trees are \"probably\" equal.\n\nRaises if the hashes are not calculated (Refer to `:auto_comp_hash` `t:opts/0`).\n\nSee also `equal?/2`.","ref":"MerkleTree.html#merkle_equal?/2"},{"type":"function","title":"MerkleTree.new/2","doc":"Create a new `t:MerkleTree.t/0` from an optional enumerable of key->value pairs.\n\nIf `enumerable` is not provided it creates an empty tree.\nThe `opts` optional parameter can be provided to customize the tree behaviour (refer to `t:opts/1`).","ref":"MerkleTree.html#new/2"},{"type":"function","title":"MerkleTree.next/1","doc":"Returns the next key in the iteration.\n\nSee also `iterator/1`.","ref":"MerkleTree.html#next/1"},{"type":"function","title":"MerkleTree.put/3","doc":"Puts the given key/value in the tree.","ref":"MerkleTree.html#put/3"},{"type":"function","title":"MerkleTree.size/1","doc":"Returns the number of keys stored in the tree.","ref":"MerkleTree.html#size/1"},{"type":"type","title":"MerkleTree.item/0","doc":"A tree item - a key/value pair.","ref":"MerkleTree.html#t:item/0"},{"type":"opaque","title":"MerkleTree.iterator/0","doc":"A tree iterator.","ref":"MerkleTree.html#t:iterator/0"},{"type":"type","title":"MerkleTree.key/0","doc":"A tree key.","ref":"MerkleTree.html#t:key/0"},{"type":"type","title":"MerkleTree.opts/0","doc":"`MerkleTree` options.\n\n- `auto_comp_hash`: tree hashes are computed on every `put/3` / `delete/2`.\n  If set to `false` hashes should be explicitly computed calling `compute_hashes/1` before\n  calling functions like `merkle_equal?/2`. Defaults to `true`.","ref":"MerkleTree.html#t:opts/0"},{"type":"type","title":"MerkleTree.t/0","doc":"Merkle tree.","ref":"MerkleTree.html#t:t/0"},{"type":"type","title":"MerkleTree.value/0","doc":"A tree value.","ref":"MerkleTree.html#t:value/0"},{"type":"extras","title":"MerkleTree","doc":"# MerkleTree\n\n[![CI](https://github.com/visciang/merkle_tree/actions/workflows/ci.yml/badge.svg)](https://github.com/visciang/merkle_tree/actions/workflows/ci.yml)\n[![Docs](https://img.shields.io/badge/docs-latest-green.svg)](https://visciang.github.io/merkle_tree/readme.html) [![Coverage Status](https://coveralls.io/repos/github/visciang/merkle_tree/badge.svg?branch=main)](https://coveralls.io/github/visciang/merkle_tree?branch=main)\n\n(Sparse) Merkle Tree.\n\n`MerkleTree` implements `Enumerable` and `Collectable` protocols.","ref":"readme.html"},{"type":"extras","title":"Quick start - MerkleTree","doc":"```elixir\nmt1 = MerkleTree.new(a: 0, b: 2, c: 3)\n\nmt2 =\n    mt1\n    |> MerkleTree.put(:a, 1)\n    |> MerkleTree.put(:d, 4)\n    |> MerkleTree.delete(:c)\n\n3 = MerkleTree.size(mt1) = MerkleTree.size(mt2)\nfalse = MerkleTree.merkle_equal?(mt1, mt2)\n[:d, :a, :c] = MerkleTree.merkle_diff(mt1, mt2)\n%{c: 3, a: 0, b: 2} = Map.new(mt1)\n```","ref":"readme.html#quick-start"}],"content_type":"text/markdown"}